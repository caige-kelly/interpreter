# Ripple Language - Project Handoff (Updated)

## Project Status
- **Lexer:** ✅ Complete and working
- **Parser:** ✅ Complete for assignments (MVP)
- **Evaluator:** ✅ Complete with trace collection (MVP)
- **Supervisor:** ✅ Complete (MVP with retry logic)
- **Tests:** ✅ Inline with source code (Zig style)
- **Type Checker:** ❌ Not started
- **VM with Bytecode:** ❌ Not started (future)

## What This Is
Ripple is a functional scripting language designed to be embedded in infrastructure/ops tools.

### Core Purpose
**"A language for infrastructure code: Lua + Elixir's reliability model + modern error handling"**

- Embedded scripting (like Lua)
- Supervisor model for process management and restarts
- Strong typing with type inference
- Effect tags (functions declare what they do: `[io]`, `[net]`, etc.)
- Result types for explicit error handling
- No if/else (match only)
- No shadowing (one binding per name)
- Configurable runtime (logging, memory limits, timeouts)

### Philosophy
**"Make bugs impossible, not syntax pretty."**
- Explicit > Clever
- Effects matter (know what functions do)
- Errors first (design around preventing mistakes)
- Types help (catch bugs at compile time)
- Keep it small

---

## Language Design (Locked In)

### Core Features
1. **Everything is a lambda** — No `fn` keyword. `add := |a, b| -> a + b`
2. **Immutability, no shadowing** — Only `:=` for binding. One name = one binding.
3. **Type inference** — Static types, inferred. Optional explicit annotations.
4. **Unified `number` type** — All numbers are `f64`. No int/float distinction (for prototype).
5. **`@` and `#` caller-driven semantics:**
   - `@` exposes Result explicitly: `ok(value, meta)` or `err(msg, meta)`
   - `#` collapses to `value | none`
6. **Operators:**
   - `|>` pipeline
   - `or` (fallback if left is none)
   - `then` (sequence if left not none)
   - `tap` (side effects without changing value)
   - `match` (pattern matching, ONLY branching construct)
7. **No if/else** — `match` handles all branching
8. **Indentation-based blocks** — Python style, strict continuation rules
9. **Effect tags on functions** — `[io]`, `[net]`, `[fx]` declare side effects
10. **Supervisor model** — Built-in process management, restarts, monitoring

### Assignment Forms (IMPLEMENTED ✅)

**Two forms:**

1. **Inferred type:** `x := 10`
   - Uses `:=` operator
   - Type is inferred by type checker (future)
   - Parser stores `type_annotation = null`

2. **Explicit type:** `x: number = 10`
   - Uses `: type =` syntax
   - Type is validated by type checker (future)
   - Parser stores `type_annotation = Type.number`

**Invalid:**
- `x = 10` — ERROR: must use `:=` or `: type =`

### Lambda Syntax (DESIGN ONLY, NOT IMPLEMENTED)

```ripple
# Single param
double := |x| -> x * 2

# Multiple params
add := |a, b| -> a + b

# With type annotations
process := |data: string| -> data |> transform

# Multi-line body (indentation-based)
complex := |x| ->
  step1 := transform(x)
  step2 := validate(step1)
  step2
```

**Key rules:**
- Params wrapped in `|...|` (pipe delimiters)
- `->` separates params from body
- Multi-line bodies require indent after `->`
- Last expression is implicit return

### Example Syntax

```ripple
# ✅ WORKS NOW
x := 10
name := "alice"
active: boolean = true
y := x  # Identifier lookup

# ❌ NOT IMPLEMENTED YET (but designed)
# Binary operators
sum := x + y

# Pipelines
result := data |> clean |> validate

# Lambdas
double := |x| -> x * 2

# Match expressions
status := code |> match ->
  200 -> "ok"
  404 -> "not found"
  any -> "error"

# Function calls
result := process(data, config)
```

---

## File Structure (Current)

```
src/
  main.zig           — Entry point, orchestration
  token.zig          — Token, TokenType, Literal definitions
  lexer.zig          — Lexer (complete) + tests inline
  types.zig          — Type enum (separate from Literal)
  ast.zig            — AST node definitions
  parser.zig         — Parser (assignments complete) + tests inline
  evaluator.zig      — Evaluator (complete for MVP) + tests inline
  supervisor.zig     — Supervisor (complete for MVP) + tests inline
  errors.zig         — Error reporting utilities

  # Future:
  type_checker.zig   — [TODO] Type checking pass
  vm.zig             — [TODO] VM with bytecode execution
build.zig            — Build configuration
```

---

## Lexer (Complete ✅)

### What It Does
- Tokenizes Ripple source code
- Tracks indentation (emits `INDENT`/`DEDENT` tokens)
- Handles `:=`, `:`, `=` correctly
- Numbers stored as `f64`
- Comments (`//` and `#`) silently consumed

### Key Tokens
- `COLON_EQUAL` (`:=`) — Inferred assignment
- `COLON` (`:`) — Type annotation start
- `EQUAL` (`=`) — Explicit assignment value
- `PIPE` (`|`) — Lambda param delimiter (future)
- `PIPELINE` (`|>`) — Pipeline operator (future)
- `ARROW` (`->`) — Lambda body separator (future)
- `INDENT`/`DEDENT` — Block structure

---

## Parser (Complete for MVP ✅)

### What Works Now

**Assignments:**
```ripple
x := 10              # Inferred
name: string = "alice"  # Explicit
```

**Literals and identifiers:**
- Numbers, strings, booleans, none
- Identifiers with lookup

### What's Missing (Future)

- Binary operators (`+`, `-`, `*`, `/`, `==`, etc.)
- Pipeline operators (`|>`, `or`, `then`)
- Lambdas (`|params| -> body`)
- Match expressions
- Function calls
- Collections (`[1, 2, 3]`, `{ key: value }`)

### Parser Structure (Precedence Chain)

```
parse()
  → parseAssignment()  ✅ DONE
    → parseLambda()    ❌ TODO
      → parsePipeline() ❌ TODO
        → parseBinary() ❌ TODO
          → parseCall() ❌ TODO
            → parsePrimary() ✅ DONE
```

---

## Evaluator (Complete for MVP ✅)

### What It Does

**Tree-walk interpreter:**
- Executes assignments
- Evaluates literals
- Looks up identifiers in symbol table
- Detects errors (undefined variables, redefinitions)
- Collects execution trace (configurable)

### Architecture

```zig
pub const Evaluator = struct {
    allocator: std.mem.Allocator,
    globals: std.StringHashMap(Value),      // Symbol table
    config: EvalConfig,                     // Runtime configuration
    results: std.ArrayList(EvalResult),     // Execution trace

    pub fn evaluate(program: Ast.Program) !Value;
    fn evalExpr(expr: Ast.Expr) !Value;
    fn evalLiteral(lit: Ast.Literal) Value;
    fn evalIdentifier(name: []const u8) !Value;
    fn evalAssignment(assign: Ast.AssignExpr) !Value;
    pub fn get_trace() []EvalResult;
};
```

### Configuration

```zig
pub const EvalConfig = struct {
    enable_trace: bool = false,  // Collect execution trace
    // Future: memory limits, timeouts, etc.
};
```

### Value Representation

```zig
pub const Value = union(enum) {
    number: f64,
    string: []const u8,
    boolean: bool,
    none,
    // Future: function, list, map
};
```

### Error Handling

```zig
pub const EvalError = error{
    UndefinedVariable,
    VariableAlreadyDefined,
    // Future: more errors
};
```

---

## Supervisor (Complete ✅)

### What It Does

**Process supervision with retry logic:**
- Runs Ripple programs under monitoring
- Restarts on evaluation errors (configurable max restarts)
- **Does NOT retry parse errors** (syntax errors can't be fixed by retrying)
- Collects execution traces from all attempts
- Measures duration across retries
- Provides detailed results (success/failure, attempts, errors)

### Architecture

```zig
pub const SupervisorConfig = struct {
    max_restarts: u32 = 3,          // How many attempts
    timeout_ms: ?u64 = null,        // [TODO] Thread-based timeout
    enable_trace: bool = true,      // Collect execution traces
};

pub const Supervisor = struct {
    allocator: Allocator,
    config: SupervisorConfig,

    // Public API
    pub fn run(source: []const u8) !SupervisionResult;

    // Internal (unit-tested)
    fn attemptRun(source: []const u8) !RunAttempt;
    fn finishAttempt(...) !RunAttempt;
    fn copyTrace(...) ![]const EvalResult;
};
```

### Two-Level Design

**Level 1: `attemptRun()` - Single Execution**
```zig
const RunAttempt = struct {
    status: Status,  // success, eval_error, parse_error
    value: ?Value,
    err: ?anyerror,
    trace: ?[]const EvalResult,  // null if parse error
    duration_ms: u64,
    memory_used: usize,
};
```

Runs the program **once**:
1. Lex → Parse → Eval (using arena allocator)
2. Copies trace to permanent memory
3. Measures duration
4. Returns detailed attempt result

**Level 2: `run()` - Retry Loop**
```zig
pub const SupervisionResult = struct {
    status: Status,  // success, failed_max_restarts, parse_error, timeout
    attempts: u32,
    final_value: ?Value,
    trace: ?[]const EvalResult,  // From final attempt
    duration_ms: u64,             // Total across all attempts
    memory_used: usize,
    last_error: ?anyerror,
    allocator: Allocator,
};
```

Orchestrates retries:
1. Calls `attemptRun()` in a loop
2. **Success** → Return immediately (no retry)
3. **Parse error** → Return immediately (no retry)
4. **Eval error** → Check if last attempt:
   - If yes → Return `failed_max_restarts`
   - If no → Free trace, retry
5. Accumulates total duration across attempts

### Retry Logic

```
Attempt 1: eval_error  → Free trace, retry
Attempt 2: eval_error  → Free trace, retry
Attempt 3: eval_error  → Keep trace, return failed_max_restarts

OR

Attempt 1: success     → Return immediately (attempts = 1)

OR

Attempt 1: parse_error → Return immediately (attempts = 1, no retry)
```

**Key insight:** Only eval errors are retried. Parse errors fail fast.

### Memory Management

**Arena for Temporary Allocations:**
```zig
var arena = std.heap.ArenaAllocator.init(self.allocator);
defer arena.deinit();
// Lexer, Parser, Evaluator all use arena.allocator()
```

**Permanent Allocator for Results:**
```zig
// Copy trace from arena to permanent memory
fn copyTrace(temp_trace: []const EvalResult) ![]const EvalResult {
    const trace_copy = try self.allocator.alloc(EvalResult, temp_trace.len);
    @memcpy(trace_copy, temp_trace);
    return trace_copy;
}
```

**Why:** Trace must outlive the function. Arena is destroyed on return.

### Testing Strategy

**Unit Tests (test `attemptRun`):**
- Success case (valid program)
- Eval error case (undefined variable)
- Parse error case (syntax error)

**Integration Tests (test `run`):**
- Success on first attempt
- Max retries exhausted (eval error × 3)
- Parse error doesn't retry

All tests use `testing.allocator` to detect memory leaks.

### Current Limitations

- ❌ No timeout implementation (requires threads)
- ❌ No memory tracking (returns 0)
- ❌ Traces from failed retry attempts are discarded (only final kept)
- ❌ No detailed trace mode (all attempts)

### Future Enhancements

**Timeout Support:**
```zig
// Spawn evaluator in thread
// Monitor with timer
// Kill thread if exceeds timeout_ms
```

**Memory Tracking:**
```zig
// Wrap allocator with GeneralPurposeAllocator
// Read total_requested_bytes after each run
```

**Detailed Traces:**
```zig
pub const SupervisorConfig = struct {
    detailed_traces: bool = false,  // Keep traces from all attempts
};

pub const SupervisionResult = struct {
    all_traces: ?[][]const EvalResult,  // If detailed_traces enabled
};
```

---

## Testing Framework (Inline with Code ✅)

### Approach
- **Tests live at the bottom of source files** (standard Zig practice)
- Use Zig's built-in `std.testing`
- Run with: `zig build test`
- Simple build.zig tests `main.zig` which imports everything

### Why Inline?
- Simpler than separate test directories
- No complex module configuration needed
- Standard Zig convention
- Tests stay close to implementation

### Test Pattern

```zig
// At bottom of evaluator.zig:

const testing = std.testing;

test "evaluate literal number" {
    const allocator = testing.allocator;

    var lexer = try @import("lexer.zig").Lexer.init("x := 42", allocator);
    const tokens = try lexer.tokenize(allocator);
    defer allocator.free(tokens);

    var parser = @import("parser.zig").Parser.init(tokens, allocator);
    const program = try parser.parse();
    defer parser.deinit();

    var evaluator = try Evaluator.init(allocator, .{});
    defer evaluator.deinit();

    const result = try evaluator.evaluate(program);
    try testing.expectEqual(Value{ .number = 42.0 }, result);
}
```

### Current Tests
- **Lexer:** Tokenization, indentation tracking
- **Parser:** Assignment parsing, literals, identifiers
- **Evaluator:** Literal evaluation, identifier lookup, assignment execution, error cases
- **Supervisor:** Single attempt (success/eval error/parse error), retry logic, max retries

**Total: 8 tests, all passing, zero memory leaks**

---

## Learning Approach (CRITICAL)

### TDD Methodology

**For all new features:**

1. **Test First** — Claude writes a failing test
2. **Implement** — You write code to make it pass
3. **Review** — Discuss quality, edge cases, design
4. **Refactor** — Improve together
5. **Repeat** — Next test, next behavior

### Why TDD?

- **Forces design thinking** — Define behavior before implementation
- **Proves correctness** — Not just "it compiles" but "it works"
- **Catches regressions** — Changes don't break existing features
- **Documents behavior** — Tests show how to use the code
- **Builds deep understanding** — Can't fake it, must know it

### Working with Claude

**Claude will:**
- Ask questions until you understand the problem
- Write tests that define expected behavior
- Point you to concepts, not just solutions
- Make you defend your architecture
- Push back on shortcuts
- Refuse to write code without your design first

**You will:**
- Think through problems before coding
- Write first implementations
- Debug your own code (with guidance)
- Defend your design choices
- Build deep knowledge, not just copy code

### Red Flags (Stop and Reconsider)
- Copying code without understanding it
- Can't explain a design decision
- Taking shortcuts to "just get it done"
- Skipping the design/thinking phase

**This is slower than receiving code. That's intentional. You're building deep knowledge.**

---

## Design Decisions Made

### 1. **Tree-Walk Interpreter First**
Not bytecode VM or JIT.

**Why:**
- Simpler to implement and understand
- Good enough for infrastructure code (I/O bound)
- Easier to instrument and supervise
- Can add VM later if needed

### 2. **Trace Collection in Evaluator**
Evaluator owns the trace ArrayList.

**Why:**
- Simple for MVP
- Configurable (can disable)
- Foundation for supervision
- Can add callbacks later if needed

### 3. **Tests Inline with Code**
Not in separate test directories.

**Why:**
- Simpler build configuration
- Standard Zig practice
- Avoids module system complexity
- Tests stay close to implementation

### 4. **No Shadowing**
Variables can't be rebound. One name = one value.

**Why:** Clarity. No confusion about which `x` you're referring to.

### 5. **Match Only (No If/Else)**
All branching through `match` expressions.

**Why:** Forces exhaustive handling. No "forgot the else branch" bugs.

### 6. **Pipes for Lambda Args**
Use `|x|` for lambda parameters.

**Why:** More explicit than bare identifiers. Rust proved the pattern works.

### 7. **Unified `number` Type**
All numbers are `f64` (for prototype).

**Why:** Simpler to implement. Can add int/float distinction later.

### 8. **Supervision Default: Trace ON**
Tracing enabled by default.

**Why:**
- Infrastructure code needs observability
- Easy to disable for performance-critical scripts
- Aligns with "safe by default" philosophy

### 9. **Memory Tracking via Allocator**
Use tracking allocator, not OS queries.

**Why:**
- Pure Zig, no syscalls
- Cross-platform
- Fast (atomic counters)
- Good enough for MVP (tracks heap allocations)

### 10. **Assignment as Statement (Not Expression)**
Assignments cannot be chained or used in expressions.

**Why:**
- Explicit > Clever (core philosophy)
- Prevents common bugs (`if (x = y)` typo in C)
- Matches modern language trend (Go, Rust, Swift)
- More readable (`x := 10; y := 20` vs `x := y := 10`)

**Trade-off:** Can't write `x := y := 10`, but that's rarely needed anyway.

### 11. **Caller Provides Allocator Pattern**
All components accept an `Allocator` parameter from the caller.

**Why:**
- Caller controls memory strategy (GPA, arena, pool, etc.)
- Clear ownership (who allocated = who frees)
- Testable (can use `testing.allocator` to detect leaks)
- Standard Zig idiom

**Pattern:**
```zig
var supervisor = Supervisor{ .allocator = my_allocator, .config = config };
var result = try supervisor.run(source);
defer result.deinit();  // Caller frees
```

### 12. **Guard Clause Style**
Prefer early returns over nested conditions.

**Why:**
- Reduces nesting depth
- Makes happy path obvious (at the end)
- Easier to reason about control flow

**Example:**
```zig
// Guard: Success - return immediately
if (result.status == .success) {
    return SupervisionResult{ ... };
}

// Guard: Parse error - don't retry
if (result.status == .parse_error) {
    return SupervisionResult{ ... };
}

// Implicit: eval_error - retry logic continues
result.deinit(allocator);
```

---

## Lessons Learned

1. **Don't speculate** — Only implement what's tested
2. **Design before code** — Understand the problem deeply
3. **Recursive descent is elegant** — Each level: call down, check, build up
4. **Indentation is manageable** — Stack-based tracking works
5. **Type vs Literal separation** — Keep parse-time and runtime distinct
6. **Tree-walk is sufficient** — Don't optimize prematurely
7. **TDD teaches deeply** — Writing tests first forces understanding
8. **Zig 0.15 has breaking changes** — Always check current docs
9. **Build system complexity** — Keep it simple until necessary
10. **Tests inline work best** — Separate test dirs are optional complexity
11. **TDD builds confidence** — Every feature proven correct by tests
12. **Unit vs Integration tests** — Integration tests for component interaction, unit tests for complex logic
13. **Memory ownership patterns** — Arena for temps, parent allocator for permanent data
14. **Off-by-one errors** — Start loop counters at values that make sense (attempts at 1, not 0)
15. **Init/deinit symmetry** — If `init()` allocates, `deinit()` must free
16. **Trace ownership transfer** — Caller owns returned memory, must free it
17. **Parse vs eval errors** — Parse errors are permanent (don't retry), eval errors might be transient
18. **Debug output pollution** — Remove `stderr` prints from library code, handle at caller level

---

## Zig 0.15.1 Specific Notes

**API Changes from Earlier Versions:**
- `ArrayList.append()` now takes allocator as parameter
- `ArrayList.init()` deprecated, use `initCapacity()`
- Module system more explicit in `build.zig`
- Imports: use `.zig` extension for relative file imports
- `std.testing` accessed through `std`, not direct import

**When continuing:**
- Check current Zig docs for API changes
- Use ChatGPT for syntax questions (has 0.15 knowledge)
- Use Claude for concepts and architecture

---

## Immediate Next Session

### Start With
"I'm continuing the Ripple language project. I have:
- ✅ Working lexer
- ✅ Working parser (for assignments)
- ✅ Working evaluator (for assignments, with trace collection)
- ✅ Working supervisor (with retry logic, tested)
- ✅ Test framework proven effective (inline tests, TDD)

I want to add [NEXT FEATURE] using TDD. One test at a time. Make me think and learn."

### Possible Next Features
- **Binary operators** (`+`, `-`, `*`, `/`, `==`, `!=`)
- **Pipeline operator** (`|>`)
- **Lambda expressions** (`|x| -> x * 2`)
- **Match expressions** (pattern matching)
- **Function calls** (`process(data, config)`)
- **Timeout support** (thread-based execution limits)

### Paste
- This handoff doc
- Any specific questions about the feature

### Explicitly State
"Use TDD: You write ONE test, I implement it, we review, repeat. Ask me questions. Make me understand before coding."

---

## Current Implementation Quality: 9/10

**What's good:**
- ✅ Clean, understandable code
- ✅ Proper error handling with retry logic
- ✅ Configurable runtime
- ✅ Comprehensive test framework (unit + integration)
- ✅ Good separation of concerns
- ✅ No memory leaks
- ✅ Production-ready Supervisor (MVP)
- ✅ TDD methodology working well

**What could improve:**
- More expression types (operators, calls, match)
- Better error messages (source locations in errors)
- Timeout implementation (requires threads)
- Memory tracking (via GPA wrapper)
- Documentation comments in code

---

## The Real Goal

**Build a language for infrastructure code that's safer, clearer, and more reliable than current alternatives.**

Success metrics:
- DevOps engineers can read and understand code immediately
- Explicit error handling prevents silent failures
- Supervision catches and recovers from failures automatically
- Effect tags make side effects visible
- Integration with logging/monitoring is seamless

Even if only a few teams use it, that's a win. The goal is to prove the concept and learn deeply.

---

## Refactoring TODOs

### Parser Cleanup
- Consider removing `Parser.init()` if it's just field assignment
- OR keep init/deinit if ArrayList field makes sense
- Decision: Does Parser need stateful accumulation, or can parse() be self-contained?

### Error Reporting
- Remove `errors.report()` calls from parser (debug noise)
- Handle error printing at CLI/REPL level (not in library code)

### Memory Tracking
- Add GPA wrapper for actual memory measurement (currently returns 0)

### Timeout Implementation
- Thread-based timeout for `timeout_ms` config
- Kill thread if execution exceeds limit

---

directive for cluade: "Use TDD: You write ONE test, I implement it, we review, repeat. Ask me questions. Make me understand before coding."

**You've built a solid foundation. The interpreter works. The supervisor works. Now add features.**

**Remember: TDD from here on. Test first, implement second, understand always.**
