# Ripple Language - Project Handoff (Updated)

## Project Status
- **Lexer:** ✅ Complete and working
- **Parser:** ✅ Complete for assignments (MVP)
- **Evaluator:** ✅ Complete with trace collection (MVP)
- **Tests:** ✅ Inline with source code (Zig style)
- **Type Checker:** ❌ Not started
- **Supervisor:** ❌ Not started (NEXT PRIORITY)
- **VM with Bytecode:** ❌ Not started (future)

## What This Is
Ripple is a functional scripting language designed to be embedded in infrastructure/ops tools.

### Core Purpose
**"A language for infrastructure code: Lua + Elixir's reliability model + modern error handling"**

- Embedded scripting (like Lua)
- Supervisor model for process management and restarts
- Strong typing with type inference
- Effect tags (functions declare what they do: `[io]`, `[net]`, etc.)
- Result types for explicit error handling
- No if/else (match only)
- No shadowing (one binding per name)
- Configurable runtime (logging, memory limits, timeouts)

### Philosophy
**"Make bugs impossible, not syntax pretty."**
- Explicit > Clever
- Effects matter (know what functions do)
- Errors first (design around preventing mistakes)
- Types help (catch bugs at compile time)
- Keep it small

---

## Language Design (Locked In)

### Core Features
1. **Everything is a lambda** — No `fn` keyword. `add := |a, b| -> a + b`
2. **Immutability, no shadowing** — Only `:=` for binding. One name = one binding.
3. **Type inference** — Static types, inferred. Optional explicit annotations.
4. **Unified `number` type** — All numbers are `f64`. No int/float distinction (for prototype).
5. **`@` and `#` caller-driven semantics:**
   - `@` exposes Result explicitly: `ok(value, meta)` or `err(msg, meta)`
   - `#` collapses to `value | none`
6. **Operators:**
   - `|>` pipeline
   - `or` (fallback if left is none)
   - `then` (sequence if left not none)
   - `tap` (side effects without changing value)
   - `match` (pattern matching, ONLY branching construct)
7. **No if/else** — `match` handles all branching
8. **Indentation-based blocks** — Python style, strict continuation rules
9. **Effect tags on functions** — `[io]`, `[net]`, `[fx]` declare side effects
10. **Supervisor model** — Built-in process management, restarts, monitoring

### Assignment Forms (IMPLEMENTED ✅)

**Two forms:**

1. **Inferred type:** `x := 10`
   - Uses `:=` operator
   - Type is inferred by type checker (future)
   - Parser stores `type_annotation = null`

2. **Explicit type:** `x: number = 10`
   - Uses `: type =` syntax
   - Type is validated by type checker (future)
   - Parser stores `type_annotation = Type.number`

**Invalid:**
- `x = 10` — ERROR: must use `:=` or `: type =`

### Lambda Syntax (DESIGN ONLY, NOT IMPLEMENTED)

```ripple
# Single param
double := |x| -> x * 2

# Multiple params
add := |a, b| -> a + b

# With type annotations
process := |data: string| -> data |> transform

# Multi-line body (indentation-based)
complex := |x| ->
  step1 := transform(x)
  step2 := validate(step1)
  step2
```

**Key rules:**
- Params wrapped in `|...|` (pipe delimiters)
- `->` separates params from body
- Multi-line bodies require indent after `->`
- Last expression is implicit return

### Example Syntax

```ripple
# ✅ WORKS NOW
x := 10
name := "alice"
active: boolean = true
y := x  # Identifier lookup

# ❌ NOT IMPLEMENTED YET (but designed)
# Binary operators
sum := x + y

# Pipelines
result := data |> clean |> validate

# Lambdas
double := |x| -> x * 2

# Match expressions
status := code |> match ->
  200 -> "ok"
  404 -> "not found"
  any -> "error"

# Function calls
result := process(data, config)
```

---

## File Structure (Current)

```
src/
  main.zig           — Entry point, orchestration
  token.zig          — Token, TokenType, Literal definitions
  lexer.zig          — Lexer (complete) + tests inline
  types.zig          — Type enum (separate from Literal)
  ast.zig            — AST node definitions
  parser.zig         — Parser (assignments complete) + tests inline
  evaluator.zig      — Evaluator (complete for MVP) + tests inline

  # Future:
  type_checker.zig   — [TODO] Type checking pass
  vm.zig             — [TODO] VM with bytecode execution
  supervisor.zig     — [TODO] Process supervision
build.zig            — Build configuration
```

---

## Lexer (Complete ✅)

### What It Does
- Tokenizes Ripple source code
- Tracks indentation (emits `INDENT`/`DEDENT` tokens)
- Handles `:=`, `:`, `=` correctly
- Numbers stored as `f64`
- Comments (`//` and `#`) silently consumed

### Key Tokens
- `COLON_EQUAL` (`:=`) — Inferred assignment
- `COLON` (`:`) — Type annotation start
- `EQUAL` (`=`) — Explicit assignment value
- `PIPE` (`|`) — Lambda param delimiter (future)
- `PIPELINE` (`|>`) — Pipeline operator (future)
- `ARROW` (`->`) — Lambda body separator (future)
- `INDENT`/`DEDENT` — Block structure

---

## Parser (Complete for MVP ✅)

### What Works Now

**Assignments:**
```ripple
x := 10              # Inferred
name: string = "alice"  # Explicit
```

**Literals and identifiers:**
- Numbers, strings, booleans, none
- Identifiers with lookup

### What's Missing (Future)

- Binary operators (`+`, `-`, `*`, `/`, `==`, etc.)
- Pipeline operators (`|>`, `or`, `then`)
- Lambdas (`|params| -> body`)
- Match expressions
- Function calls
- Collections (`[1, 2, 3]`, `{ key: value }`)

### Parser Structure (Precedence Chain)

```
parse()
  → parseAssignment()  ✅ DONE
    → parseLambda()    ❌ TODO
      → parsePipeline() ❌ TODO
        → parseBinary() ❌ TODO
          → parseCall() ❌ TODO
            → parsePrimary() ✅ DONE
```

---

## Evaluator (Complete for MVP ✅)

### What It Does

**Tree-walk interpreter:**
- Executes assignments
- Evaluates literals
- Looks up identifiers in symbol table
- Detects errors (undefined variables, redefinitions)
- Collects execution trace (configurable)

### Architecture

```zig
pub const Evaluator = struct {
    allocator: std.mem.Allocator,
    globals: std.StringHashMap(Value),      // Symbol table
    config: EvalConfig,                     // Runtime configuration
    results: std.ArrayList(EvalResult),     // Execution trace

    pub fn evaluate(program: Ast.Program) !Value;
    fn evalExpr(expr: Ast.Expr) !Value;
    fn evalLiteral(lit: Ast.Literal) Value;
    fn evalIdentifier(name: []const u8) !Value;
    fn evalAssignment(assign: Ast.AssignExpr) !Value;
    pub fn get_trace() []EvalResult;
};
```

### Configuration

```zig
pub const EvalConfig = struct {
    enable_trace: bool = false,  // Collect execution trace
    // Future: memory limits, timeouts, etc.
};
```

### Value Representation

```zig
pub const Value = union(enum) {
    number: f64,
    string: []const u8,
    boolean: bool,
    none,
    // Future: function, list, map
};
```

### Error Handling

```zig
pub const EvalError = error{
    UndefinedVariable,
    VariableAlreadyDefined,
    // Future: more errors
};
```

---

## Testing Framework (Inline with Code ✅)

### Approach
- **Tests live at the bottom of source files** (standard Zig practice)
- Use Zig's built-in `std.testing`
- Run with: `zig build test`
- Simple build.zig tests `main.zig` which imports everything

### Why Inline?
- Simpler than separate test directories
- No complex module configuration needed
- Standard Zig convention
- Tests stay close to implementation

### Test Pattern

```zig
// At bottom of evaluator.zig:

const testing = std.testing;

test "evaluate literal number" {
    const allocator = testing.allocator;

    var lexer = try @import("lexer.zig").Lexer.init("x := 42", allocator);
    const tokens = try lexer.tokenize(allocator);
    defer allocator.free(tokens);

    var parser = @import("parser.zig").Parser.init(tokens, allocator);
    const program = try parser.parse();
    defer parser.deinit();

    var evaluator = try Evaluator.init(allocator, .{});
    defer evaluator.deinit();

    const result = try evaluator.evaluate(program);
    try testing.expectEqual(Value{ .number = 42.0 }, result);
}
```

### Current Tests
- Literal evaluation (numbers, strings, booleans, none)
- Identifier lookup
- Assignment execution
- Error cases (undefined vars, redefinition)
- Trace collection

---

## Next Steps: Supervisor (PRIORITY)

### Goal
Build a supervisor that can:
1. Run Ripple programs under monitoring
2. Restart on failure (configurable max restarts)
3. Enforce resource limits (memory, timeout)
4. Collect execution traces
5. Provide detailed results (success/failure, attempts, errors)

### Design Philosophy
**Model after BEAM/Erlang supervision**, but adapted for:
- Short-lived scripts (not long-running processes)
- Infrastructure/ops workloads (I/O bound, not CPU bound)
- Explicit configuration (script-level or external)

### Supervisor Model

```
Supervisor
    ↓
  spawns
    ↓
Process (Evaluator)
    ↓
  runs
    ↓
Lex → Parse → Eval (tree-walk)
    ↓
If crashes → Supervisor decides: restart? fail? fallback?
```

### Initial API Design

```zig
pub const SupervisorConfig = struct {
    max_restarts: u32 = 3,
    timeout_ms: ?u64 = null,
    max_memory_bytes: ?usize = null,  // Track via allocator
    enable_trace: bool = true,
};

pub const Supervisor = struct {
    allocator: Allocator,
    config: SupervisorConfig,

    pub fn run(source: []const u8) !SupervisionResult;
};

pub const SupervisionResult = struct {
    status: Status,  // success, failed_max_restarts, timeout, etc.
    value: ?Value,
    attempts: u32,
    trace: []const EvalResult,
    memory_used: usize,
    duration_ms: u64,
    last_error: ?anyerror,
};
```

### Development Approach
**Test-Driven Development (TDD):**
1. Write ONE test for a specific behavior
2. Implement minimum code to pass
3. Review and refactor
4. Repeat

This builds understanding incrementally rather than receiving large code blocks.

---

## Learning Approach (CRITICAL)

### TDD Methodology

**For all new features (Supervisor, future work):**

1. **Test First** — Claude writes a failing test
2. **Implement** — You write code to make it pass
3. **Review** — Discuss quality, edge cases, design
4. **Refactor** — Improve together
5. **Repeat** — Next test, next behavior

### Why TDD?

- **Forces design thinking** — Define behavior before implementation
- **Proves correctness** — Not just "it compiles" but "it works"
- **Catches regressions** — Changes don't break existing features
- **Documents behavior** — Tests show how to use the code
- **Builds deep understanding** — Can't fake it, must know it

### Working with Claude

**Claude will:**
- Ask questions until you understand the problem
- Write tests that define expected behavior
- Point you to concepts, not just solutions
- Make you defend your architecture
- Push back on shortcuts
- Refuse to write code without your design first

**You will:**
- Think through problems before coding
- Write first implementations
- Debug your own code (with guidance)
- Defend your design choices
- Build deep knowledge, not just copy code

### Red Flags (Stop and Reconsider)
- Copying code without understanding it
- Can't explain a design decision
- Taking shortcuts to "just get it done"
- Skipping the design/thinking phase

**This is slower than receiving code. That's intentional. You're building deep knowledge.**

---

## Design Decisions Made

### 1. **Tree-Walk Interpreter First**
Not bytecode VM or JIT.

**Why:**
- Simpler to implement and understand
- Good enough for infrastructure code (I/O bound)
- Easier to instrument and supervise
- Can add VM later if needed

### 2. **Trace Collection in Evaluator**
Evaluator owns the trace ArrayList.

**Why:**
- Simple for MVP
- Configurable (can disable)
- Foundation for supervision
- Can add callbacks later if needed

### 3. **Tests Inline with Code**
Not in separate test directories.

**Why:**
- Simpler build configuration
- Standard Zig practice
- Avoids module system complexity
- Tests stay close to implementation

### 4. **No Shadowing**
Variables can't be rebound. One name = one value.

**Why:** Clarity. No confusion about which `x` you're referring to.

### 5. **Match Only (No If/Else)**
All branching through `match` expressions.

**Why:** Forces exhaustive handling. No "forgot the else branch" bugs.

### 6. **Pipes for Lambda Args**
Use `|x|` for lambda parameters.

**Why:** More explicit than bare identifiers. Rust proved the pattern works.

### 7. **Unified `number` Type**
All numbers are `f64` (for prototype).

**Why:** Simpler to implement. Can add int/float distinction later.

### 8. **Supervision Default: Trace ON**
Tracing enabled by default.

**Why:**
- Infrastructure code needs observability
- Easy to disable for performance-critical scripts
- Aligns with "safe by default" philosophy

### 9. **Memory Tracking via Allocator**
Use tracking allocator, not OS queries.

**Why:**
- Pure Zig, no syscalls
- Cross-platform
- Fast (atomic counters)
- Good enough for MVP (tracks heap allocations)

---

## Lessons Learned

1. **Don't speculate** — Only implement what's tested
2. **Design before code** — Understand the problem deeply
3. **Recursive descent is elegant** — Each level: call down, check, build up
4. **Indentation is manageable** — Stack-based tracking works
5. **Type vs Literal separation** — Keep parse-time and runtime distinct
6. **Tree-walk is sufficient** — Don't optimize prematurely
7. **TDD teaches deeply** — Writing tests first forces understanding
8. **Zig 0.15 has breaking changes** — Always check current docs
9. **Build system complexity** — Keep it simple until necessary
10. **Tests inline work best** — Separate test dirs are optional complexity

---

## Zig 0.15.1 Specific Notes

**API Changes from Earlier Versions:**
- `ArrayList.append()` now takes allocator as parameter
- `ArrayList.init()` deprecated, use `initCapacity()`
- Module system more explicit in `build.zig`
- Imports: use `.zig` extension for relative file imports
- `std.testing` accessed through `std`, not direct import

**When continuing:**
- Check current Zig docs for API changes
- Use ChatGPT for syntax questions (has 0.15 knowledge)
- Use Claude for concepts and architecture

---

## Immediate Next Session

### Start With
"I'm continuing the Ripple language project. I have:
- ✅ Working lexer
- ✅ Working parser (for assignments)
- ✅ Working evaluator (for assignments, with trace collection)
- ✅ Test framework set up (inline tests)

I want to build the Supervisor next using TDD. One test at a time. Make me think and learn."

### Paste
- This handoff doc
- Any specific questions about the Supervisor design

### Explicitly State
"Use TDD: You write ONE test, I implement it, we review, repeat. Ask me questions. Make me understand before coding."

---

## Current Implementation Quality: 8/10

**What's good:**
- Clean, understandable code
- Proper error handling
- Configurable runtime
- Test framework in place
- Good separation of concerns

**What could improve:**
- More expression types (operators, calls, match)
- Better error messages (source locations)
- More comprehensive tests
- Documentation comments in code

---

## The Real Goal

**Build a language for infrastructure code that's safer, clearer, and more reliable than current alternatives.**

Success metrics:
- DevOps engineers can read and understand code immediately
- Explicit error handling prevents silent failures
- Supervision catches and recovers from failures automatically
- Effect tags make side effects visible
- Integration with logging/monitoring is seamless

Even if only a few teams use it, that's a win. The goal is to prove the concept and learn deeply.

---

**You've built a solid foundation. The interpreter works. Now make it reliable with supervision.**

**Remember: TDD from here on. Test first, implement second, understand always.**
