# Ripple Language - Project Handoff (v2.0)

**Source of Truth:** Reference script (v5.0) - included in project documents

---

## Project Status

### Implemented ✅
- **Lexer:** Functional style, complete tokenization
  - Numbers (int/float, including negative)
  - Strings (with escape sequences: `\n`, `\t`, `\"`, `\\`)
  - Booleans (`true`, `false`)
  - Keywords (`none`, `match`, `try`, `or`, `then`, `tap`)
  - All operators
- **Parser:** Functional style with precedence climbing
  - Binary operators with correct precedence
  - Unary operators (`-`, `!`)
  - Assignments (no shadowing allowed)
- **Evaluator:** Functional style with type-aware operators
  - Arithmetic: `+`, `-`, `*`, `/` (numbers and string concatenation)
  - Comparisons: `==`, `!=`, `<`, `<=`, `>`, `>=`
  - Unary: `-` (negate numbers), `!` (negate booleans)
  - Type checking with clear error messages
- **Supervisor:** Arena-based with proper trace handling
- **Tests:** 56 passing, zero memory leaks

### Next to Implement 🔨
- **Functions/Lambdas:** `add := x, y -> x + y` (syntax TBD: `x ->` vs `|x|`)
- **Function calls:** `add 10 32`
- **Lists:** `[1, 2, 3]`
- **Maps:** `{id: 42, name: "alice"}`

### Designed but Not Implemented ⏳
- **Pipeline operator:** `|>`
- **Result type:** `Result<T, E, S>` with dual channels (user + system)
- **Domain markers:** `@` (monadic) vs `#` (tolerant)
- **Error handling operators:** `or`, `then`, `tap`
- **Match expressions:** pattern matching instead of if/else
- **Standard library:** File, Map, Net, IO, etc.

### Not Planned ❌
- Boolean operators: `and`, `or`, `not` (use match instead)
- If/else statements (use match expressions)
- While loops (use recursion or pipelines)

---

## Language Philosophy

**Ripple is a functional, pipeline-oriented language with explicit error handling.**

### Core Principles
1. **No if/else** - Use pattern matching via `match`
2. **No boolean operators** - Match expressions replace boolean logic
3. **Explicit error handling** - Result type with dual channels (user + system)
4. **Immutable by default** - Rebinding creates new bindings (shadowing)
5. **Clean syntax** - Minimal symbols, relying on IDE for type information
6. **Pipelines first** - Data flows through transformations via `|>`

### Design Philosophy: Language + IDE Partnership
- Syntax is intentionally clean (like Python)
- Type rigor provided by IDE tooling (like Haskell)
- Hover to see inferred types
- IDE marks `@` vs `#` functions differently
- Verbose tracing available via IDE plugin

---

## Type System

### Fundamental Types
```ripple
x := 42                    // number (int precision)
y := 3.14                  // number (float)
name := "alice"            // string
active := true             // bool
nothing := none            // none type
```

**Note:** `number` unifies int/float (preserves int precision when possible)

### Composite Types
```ripple
numbers := [1, 2, 3]       // [T] - list of T
user := {                   // {key: T} - map
  id: 42,
  name: "alice"
}
```

### Result Type (Core to Error Handling)
```ripple
Result<V, E, S> = ok(V, S) | err(E, S)
```

**Dual channel structure:**
- **user channel:** `V` or `E` - the semantic value (what your code cares about)
- **sys channel:** `S` - system metadata (duration, status, retries, etc.)

**Shorthands:**
```ripple
ok(v)        ≡ ok(v, none)      // Success with value, no metadata
ok(_, s)     ≡ ok(none, s)      // Success with metadata only
err(v)       ≡ err(v, none)     // Error with message
err(_, s)    ≡ err(none, s)     // Error with metadata only
```

---

## Domain Markers: @ vs #

**Critical Language Feature:** Functions are marked at definition to declare error handling semantics.

### @ - Monadic Domain
Returns `Result<T, E>` - caller must handle both success and failure channels.

```ripple
@fetch_user := id ->
  @Net.get ("https://api.example.com/users/" + id)
    |> @Map.parse _
    |> @Map.translate default _ { id: id, name: name }

// Caller handles Result explicitly
result := @fetch_user 123
result |> match ->
  ok(user, meta) ->
    #IO.stdout ("Fetched: " + user.name)
  err(msg, meta) ->
    @Slack.post ("Error: " + msg)
```

### # - Tolerant Domain
Returns `value | none` - errors are suppressed, returns none on failure.

```ripple
#load_config := path ->
  #File.read path
    |> #Map.parse _
    or #Map.new { env: "dev" }

// Caller gets value or none (no explicit error handling needed)
config := #load_config "./config.json"
```

### Result Interpretation (Caller-Driven)
Standard library returns `Result<T, E>` by default. Caller chooses interpretation:

```ripple
// Monadic: Use @ to expose both channels
response := @Net.get "https://example.com/api"

// Tolerant: Use # to collapse to value | none
data := #Net.get "https://example.com/api"
// If success: data = body
// If failure: data = none
```

---

## Variables & Immutability

### Type Inference (Default - 90% of use)
```ripple
x := 42                    // Inferred as number
name := "alice"            // Inferred as string
```

### Explicit Type Annotation (Rare - for clarity)
```ripple
result: Result<User, Error> =
  @Net.get url
    |> @Map.parse _
    |> @Map.validate schema _
```

### Shadowing (Rebinding)
```ripple
count := 1
count := count + 1         // Shadows previous, now 2
count := count * 2         // Shadows again, now 4
```

**All variables are immutable.** Rebinding with `:=` creates new binding; old is unreachable.

---

## Functions

**Everything is a lambda bound to a name.** No `fn` keyword.

### Simple Functions
```ripple
add := a, b -> a + b
result := add 10 32        // result = 42
```

### Multi-line Functions
```ripple
process := x ->
  y := x + 1
  z := y * 2
  z                        // Implicit return of last expression
```

### Functions with Type Annotations (Optional)
```ripple
multiply := x: number, y: number ->
  x * y
```

### Monadic Functions (@ domain)
```ripple
@fetch_user := id ->
  @Net.get ("https://api.example.com/users/" + id)
    |> @Map.parse _
    |> @Map.translate default _ { id: id, name: name }
```

### Tolerant Functions (# domain)
```ripple
#load_config := path ->
  #File.read path
    |> #Map.parse _
    or #Map.new { env: "dev" }
```

**Note:** Lambda parameter syntax is TBD: `x ->` vs `|x|` (to be determined during implementation)

---

## Operators

### Implemented ✅

#### Arithmetic
```ripple
sum := 2 + 3               // number + number
diff := 10 - 5             // number - number
product := 3 * 4           // number * number
quotient := 10 / 2         // number / number (errors on divide by zero)
```

#### String Concatenation
```ripple
greeting := "hello" + " world"    // string + string
```

#### Comparisons (Numbers only, returns boolean)
```ripple
equal := 5 == 5            // true
not_equal := 5 != 3        // true
less := 3 < 5              // true
less_equal := 3 <= 3       // true
greater := 5 > 3           // true
greater_equal := 5 >= 5    // true
```

#### Equality (Works on any matching types)
```ripple
num_equal := 5 == 5                    // true
str_equal := "hello" == "hello"        // true
bool_equal := true == true             // true
type_mismatch := 5 == "5"              // false (different types)
```

### To Be Implemented ⏳

#### Pipeline Operator
```ripple
result :=
  "hello world"
    |> #String.uppercase _
    |> #String.split " "
```

#### or - Fallback for none (Monoid identity: none)
```ripple
config :=
  #File.read "./optional.json"
    or #Map.new { default: true }
```

#### then - Sequencing (only if left is not none)
```ripple
result :=
  #File.read "./required.json"
    then #Map.parse _
    then #Map.validate schema _
```

#### tap - Observational Side Effects
```ripple
// Observe errors without changing the value
result :=
  @Net.post url payload
    |> tap err(msg, meta) ->
         @Slack.post ("Error: " + msg)
    or #Map.new { status: "failed" }

// Observe success
data :=
  @Net.get url
    |> tap ok(body, meta) ->
         @IO.stdout ("Fetched: " + body)
    |> @Map.parse _
```

**tap algebra:**
- `tap f (ok(u, s)) = ok(u, s)` - Returns original ok unchanged
- `tap f (err(u, s)) = f(u, s) then err(u, s)` - Runs side effect, returns original err

---

## Pattern Matching

**Replaces if/else statements entirely.**

### Match on Result
```ripple
response :=
  @Net.get "https://example.com/status"
    |> match ->
         ok(body, meta) ->
           "Service healthy: " + body.status
         err(msg, meta) ->
           "Service down: " + msg
```

### Match on Values
```ripple
status := "active"
message :=
  status |> match ->
    "active" -> "Running"
    "paused" -> "Paused"
    any -> "Unknown"
```

### Match Syntax
```ripple
value |> match ->
  pattern1 -> result1
  pattern2 -> result2
  any -> default_result
```

**No `|` before patterns** - just indentation and `->` arrows.

---

## Collections

### Lists
```ripple
numbers := [1, 2, 3, 4, 5]
empty_list := []

nested := [
  [1, 2],
  [3, 4]
]
```

### Maps
```ripple
user := {
  id: 42,
  name: "alice",
  email: "alice@example.com"
}

empty_map := {}

// Map access (returns none if key missing)
user_name := #Map.get user "name"    // "alice" or none
user_name or "unknown"
```

---

## Program Supervision & Tracing

### Verbosity Levels
```ripple
#Program.verbosity = "quiet"      // No trace logs
#Program.verbosity = "normal"     // Standard logs
#Program.verbosity = "verbose"    // Log EVERY expression
```

### Trace Format (verbose mode)
```
line :: binding :: function/operator :: user_value :: system_value
```

**Example trace lines:**
```
15 :: config :: #File.read :: "..." :: {duration: 2ms}
28 :: _ :: @Net.get :: err("ECONNREFUSED") :: {retries: 3, ms: 1200}
29 :: _ :: tap :: ok(...) :: {side_effect: "slack_posted"}
30 :: deploy :: or :: {status: "skipped"} :: {source: "fallback"}
```

**Traces are observational only** - they do NOT affect execution semantics.

---

## Memory Management Strategy

### Arena Per Execution
```zig
fn attemptRun(source: []const u8) !RunAttempt {
    var arena = ArenaAllocator.init(self.allocator);
    defer arena.deinit();  // Frees everything temporary

    // All temporary data uses arena
    const tokens = try tokenize(source, arena.allocator());
    const program = try parse(tokens, arena.allocator());
    var eval_result = try evaluate(program, arena.allocator(), config);
    defer eval_result.deinit();

    // Copy what needs to survive to permanent memory
    const trace_copy = try self.allocator.alloc(TraceEntry, eval_result.trace.len);
    @memcpy(trace_copy, eval_result.trace);

    return RunAttempt{
        .trace = trace_copy,  // Lives in self.allocator
        .value = eval_result.value,
    };
}
```

**Pattern:**
- **Arena** = temporary (tokens, AST, eval state)
- **Permanent allocator** = results that outlive execution (traces, values)
- **Copy** between them when needed

---

## Current Implementation Details

### Architecture: Functional Style

**Before (OO):**
```zig
var lexer = try Lexer.init(source, allocator);
defer lexer.deinit();
const tokens = try lexer.tokenize();
```

**After (Functional):**
```zig
const tokens = try tokenize(source, allocator);
// No deinit needed - arena handles everything
```

### File Structure

#### Clean and Working ✅
- `lexer.zig` - Functional, tokenizes all operators
- `parser.zig` - Functional, precedence climbing
- `evaluator.zig` - Functional, type-aware operators
- `supervisor.zig` - OO (stateful orchestration)
- `ast.zig` - Data structures with deinit methods
- `token.zig` - Token definitions
- `error.zig` - Error reporting
- `build.zig` - Build configuration

### Test Pattern (Standardized)
```zig
test "feature name" {
    const allocator = testing.allocator;
    var arena = std.heap.ArenaAllocator.init(allocator);
    defer arena.deinit();

    const source = "x := 42";
    const tokens = try @import("lexer.zig").tokenize(source, arena.allocator());
    var program = try @import("parser.zig").parse(tokens, arena.allocator());
    defer program.deinit();

    var result = try evaluate(program, arena.allocator(), .{});
    defer result.deinit();

    try testing.expectEqual(expected, result.value);
}
```

### Current Test Status
**56 tests passing, 0 memory leaks**

**Test coverage:**
- ✅ Lexer: tokenization of all operators, literals, keywords
- ✅ Parser: precedence, binary/unary expressions, assignments
- ✅ Evaluator: arithmetic, comparisons, type checking, string ops
- ✅ Supervisor: retries, trace collection, memory management
- ✅ Edge cases: empty strings, escape sequences, negative numbers, type mismatches
- ✅ Error handling: undefined variables, type mismatches, division by zero, no shadowing

---

## Language Features

### Working Now ✅
```ripple
// Variables
x := 10                    // Inferred assignment
name: string = "alice"     // Explicit type (rare)

// Arithmetic
result := 3 * 4            // Multiplication
sum := 2 + 3               // Addition
diff := 10 - 5             // Subtraction
quotient := 10 / 2         // Division

// Negative numbers
x := -42                   // Negative literal
y := 5 + -3                // Negative in expression
z := -x                    // Negate variable

// Strings
greeting := "hello" + " world"  // Concatenation
newline := "line1\nline2"      // Escape sequences: \n \t \" \\
empty := ""                     // Empty string

// Booleans
is_valid := true
is_active := false
toggled := !is_valid       // Negation

// Comparisons (return boolean)
equal := x == y            // Equality (works for all types)
not_equal := x != y        // Inequality
greater := x > 5           // Greater than (numbers only)
less_equal := x <= 10      // Less than or equal

// Complex expressions
result := 2 + 3 * 4        // Precedence: 14 (not 20)
calc := 10 - 5 - 2         // Left-to-right: 3
check := 5 == 5            // true
mixed := "a" != "b"        // true

// None
nothing := none
is_none := none == none    // true
```

### Next to Build 🔨
```ripple
// Functions
add := a, b -> a + b       // Definition (syntax TBD: x -> vs |x|)
result := add 10 32        // Call

// Lists
numbers := [1, 2, 3]
first := numbers[0]

// Maps
user := {id: 42, name: "alice"}
name := user.name
```

### Coming Later ⏳
```ripple
// Pipelines
result := data |> validate |> transform

// Error handling
config :=
  #File.read "./config.json"
    or #Map.new {default: true}

// Match expressions
result := status |> match ->
  "active" -> "Running"
  "paused" -> "Paused"
  any -> "Unknown"

// Monadic error handling
result :=
  @Net.get url
    |> @Map.parse _
    |> tap err(msg, meta) ->
         @Slack.post ("Error: " + msg)
```

---

## Standard Library (Designed, Not Implemented)

### File I/O
```ripple
@File.read := path -> Result<string, Error>
@File.write := path data -> Result<none, Error>
```

### Map Operations
```ripple
@Map.parse := text -> Result<Map, Error>
@Map.validate := map schema -> Result<Map, Error>
@Map.get := map key -> value | none
@Map.new := initial_data -> Map
```

### Network
```ripple
@Net.get := url -> Result<string, Error>
@Net.post := url data -> Result<string, Error>
```

### String Operations
```ripple
#String.uppercase := text -> string
#String.split := text sep -> [string]
```

### IO
```ripple
@IO.stdout := message -> Result<none, Error>
@IO.exit := code -> Result<none, Error>
```

### Slack Integration
```ripple
@Slack.post := message -> Result<none, Error>
```

---

## Roadmap

### Phase 1: Foundation (Current)
1. ✅ Basic types (number, string, bool, none)
2. ✅ Arithmetic operators
3. ✅ Comparison operators
4. ✅ String concatenation
5. 🔨 Functions and lambdas
6. 🔨 Function calls
7. 🔨 Lists
8. 🔨 Maps

### Phase 2: Core Ripple Features
1. Pipeline operator `|>`
2. `or` operator (fallback)
3. `then` operator (sequencing)
4. Basic pattern matching (match expressions)
5. Result type (ok/err)

### Phase 3: Error Handling
1. `@` vs `#` domain markers
2. `tap` operator (side effects)
3. Dual-channel Result (user + sys)
4. Error propagation

### Phase 4: Standard Library
1. File I/O
2. Map operations
3. Network operations
4. String operations
5. IO operations

### Phase 5: Advanced Features
1. Pattern matching with guards
2. Destructuring in match
3. List comprehensions
4. Advanced stdlib functions

---

## Design Decisions

### Why Functional Style?
- ✅ Simple operations (input → output)
- ✅ No persistent state needed
- ✅ Easier to test (pure functions)
- ✅ Matches language philosophy

### Why OO for Supervisor?
- ✅ Stateful orchestration
- ✅ Configuration management
- ✅ Multiple method coordination

### Why Arena for Temporary, GPA for Permanent?
- Temporary data (tokens, AST) dies together → arena perfect
- Permanent data (traces, results) lives longer → explicit allocation
- Clear separation of lifetimes
- No manual cleanup of temporaries

### Why Keep deinit Methods?
- Flexibility for non-arena usage (REPL, caching, hot-reload)
- Explicit ownership (clear who frees what)
- Harmless with arena (calling deinit is a no-op)
- Future-proof for features not yet designed

### Why No Boolean Operators?
- Match expressions replace if/else
- Pattern matching covers all boolean logic use cases
- Simpler language
- Philosophically consistent with functional approach

### Why No Variable Shadowing?

**Ripple does NOT allow variable shadowing.** Once a variable is defined, it cannot be redefined in the same scope.

**Rationale:**
1. **Pipelines eliminate the need** - Use `|>` for transformations instead
2. **Explicitness over writability** - Different values should have different names
3. **Catch bugs early** - Typos and accidental redefinition caught at compile time
4. **Philosophy: "Make bugs difficult"** - Force clear, explicit code

**Anti-pattern:**
```ripple
config := #File.read path
config := config |> #Map.parse     // ERROR: config already defined
config := config or #Map.new {default: true}
```

**Correct pattern:**
```ripple
config := #File.read path 
  |> #Map.parse 
  or #Map.new {default: true}
```

**Why no exception for "x := x + 1"?**
Even simple rebinding should use pipelines or unique names:
```ripple
// Bad (not allowed)
count := 1
count := count + 1  // ERROR: count already defined

// Good - explicit progression
count := 1
count_incremented := count + 1
final_count := count_incremented + 1

// Or use a pipeline (future)
count := 1 |> increment |> increment
```

### Why No Parentheses for Grouping? (Yet)

**Decision:** Ripple does not currently support parentheses `()` for expression grouping.

**Rationale:**
- **Minimalism:** Don't add features until proven necessary
- **Precedence handles most cases:** Unary operators and precedence rules cover common needs
- **Can always add later:** If users demonstrate a real need, we'll add them
- **Philosophy:** "Explicitness > writability" - if you need complex grouping, break into steps

**Known limitation:**
```ripple
# Cannot express: -(a - b) directly
# Workaround: use intermediate variable
temp := a - b
result := -temp

# Or later with functions:
result := negate(a - b)
```

**When we'll add them:** When a user shows a real-world use case that can't be solved with:
1. Intermediate variables
2. Different operator ordering
3. Function composition

**Current workarounds:**
```ripple
# Most cases work fine without parens
x := -5 * 3        # -15 (unary - has highest precedence)
y := 2 + 3 * 4     # 14 (precedence: * before +)
z := -x + -y       # Negate multiple values

# Edge case: -(a - b)
# Workaround 1: intermediate variable
temp := a - b
result := -temp

# Workaround 2: rewrite mathematically
result := -a + b   # Equivalent to -(a - b)
```

---

## Next Session Starter

**"I'm continuing Ripple. Current status:**
- ✅ 30 tests passing, zero leaks
- ✅ Arithmetic, comparisons, strings working
- ✅ Reference script (v5.0) is source of truth
- ✅ @ vs # domains designed (not implemented)
- ✅ Result type designed (not implemented)

**I want to implement functions with TDD. Syntax decision: `x ->` vs `|x|` - we'll discover edge cases through testing. Write ONE test for simple function definition and call, I'll implement it, we review, repeat."**

---

## Quick Reference Commands

```bash
# All tests
zig build test

# With summary
zig build test --summary all

# Individual file
zig test src/evaluator.zig
```

---

## Testing Strategy & Roadmap

### Current Testing Approach
**Unit Tests (30 passing)** - Testing individual components in isolation:
- Lexer: tokenization of all operators and literals
- Parser: precedence, binary expressions, assignments
- Evaluator: arithmetic, comparisons, type checking, string operations
- Supervisor: retries, trace collection, memory management

**Pattern:** TDD (Test-Driven Development)
- Write ONE failing test
- Implement just enough to pass
- Refactor if needed
- Repeat

### Testing Phases

#### Phase 1: Component Tests (Current - 30 tests)
Testing individual compiler/interpreter components:
- ✅ Lexer correctness
- ✅ Parser precedence
- ✅ Evaluator semantics
- ✅ Memory leak detection
- 🔨 Function definition and calls
- 🔨 Lambda expressions
- 🔨 Pipeline operator

#### Phase 2: Language Feature Tests (Next - Target: 75 tests)
Testing complete language features end-to-end:
- Function composition
- Pattern matching
- Error handling (or, then, tap)
- Result type behavior
- @ vs # domain interpretation
- Collection operations (lists, maps)

#### Phase 3: Ripple Conformance Suite (Target: 100+ tests)
**Custom test suite proving Ripple is "minimally useful"**

Create `conformance/` directory with `.ripple` test programs:

```
conformance/
├── 01_basic_arithmetic.ripple       # Math operations
├── 02_string_operations.ripple      # String manipulation
├── 03_functions.ripple               # Function definition and calls
├── 04_pipelines.ripple              # Pipeline operator
├── 05_error_handling.ripple         # or, then, tap
├── 06_pattern_matching.ripple       # match expressions
├── 07_collections.ripple            # Lists and maps
├── 08_recursion.ripple              # Recursive functions
├── 09_higher_order.ripple           # Functions as values
└── 10_real_world.ripple             # Practical example
```

**Each file should:**
- Demonstrate a core language feature
- Include edge cases
- Have expected output documented
- Be runnable via `ripple run conformance/XX_name.ripple`

#### Phase 4: Rosetta Code Problems (Target: 20 programs)
**Prove Ripple can solve real programming tasks**

Port problems from http://rosettacode.org/ to validate feature completeness:

**Essential Problems (Must Have):**
1. **FizzBuzz** - Basic control flow
2. **Fibonacci** - Recursion
3. **Factorial** - Simple recursion
4. **Quicksort** - Recursion + lists
5. **Filter/Map/Reduce** - Higher-order functions
6. **String reversal** - String manipulation
7. **Palindrome check** - String + logic
8. **Sum and product** - List operations
9. **File I/O** - Read/write files
10. **CSV parsing** - Practical data handling

**Stretch Goals:**
11. Binary search
12. Merge sort
13. Prime numbers
14. Roman numerals
15. Anagrams
16. Word count
17. JSON parsing
18. HTTP request
19. Data validation
20. Pipeline data transformation

Create `rosetta/` directory:
```
rosetta/
├── fizzbuzz.ripple
├── fibonacci.ripple
├── factorial.ripple
├── quicksort.ripple
├── map_filter_reduce.ripple
└── ...
```

#### Phase 5: Benchmark Suite (Future - Performance validation)
**Adapted from The Computer Language Benchmarks Game**

Not about winning, just being "reasonable":
- n-body simulation
- Binary trees
- Fannkuch-redux

Create `benchmarks/` directory with:
- Ripple implementations
- Timing infrastructure
- Memory usage tracking
- Comparison with reference implementations (optional)

### Success Criteria by Phase

**Phase 1 (Current):** ✅ Complete
- All component tests passing
- Zero memory leaks
- Clean architecture

**Phase 2:** Feature Complete
- All designed operators working
- Functions and lambdas functional
- Pattern matching operational
- Result type implemented
- Can write useful programs

**Phase 3:** Minimally Useful Language
- All conformance tests pass
- Demonstrates core Ripple philosophy (pipelines, error handling)
- Proof that Ripple can express real logic

**Phase 4:** Practically Viable
- Can solve standard programming problems
- Comparable to other scripting languages
- Ready for early adopters

**Phase 5:** Production Ready
- Reasonable performance characteristics
- Stable enough for real projects
- Clear performance trade-offs documented

### Testing Infrastructure Needs

**Now:**
- ✅ Zig's built-in test framework
- ✅ Memory leak detection via allocator
- ✅ Individual file testing

**Soon:**
- 🔨 Test runner for `.ripple` files
- 🔨 Expected output assertions
- 🔨 Test harness for conformance suite

**Later:**
- ⏳ Benchmark timing infrastructure
- ⏳ Performance regression detection
- ⏳ Integration test suite
- ⏳ Fuzzing for edge cases

### Example Conformance Test Structure

**File:** `conformance/04_pipelines.ripple`
```ripple
// Test: Basic pipeline
result := "hello" |> #String.uppercase
// Expected: "HELLO"

// Test: Multi-stage pipeline
numbers := [1, 2, 3, 4, 5]
result := numbers
  |> filter (x -> x > 2)
  |> map (x -> x * 2)
// Expected: [6, 8, 10]

// Test: Pipeline with error handling
result :=
  #File.read "./missing.json"
    |> #Map.parse _
    or #Map.new {default: true}
// Expected: {default: true}
```

**Assertion format TBD** - options:
1. Comments with expected values (manual verification)
2. Built-in `assert` function
3. External test runner that parses output
4. Compiler-verified doc tests (like Rust)

---

## Current Quality: 7/10

**What's good:**
- ✅ Solid foundation (lexer, parser, evaluator)
- ✅ Clean functional architecture
- ✅ Zero memory leaks
- ✅ Clear roadmap with reference script
- ✅ @ vs # design is sophisticated

**What's next:**
- Add functions (the big one)
- Then pipelines (killer feature)
- Then Result type and error handling
- Build out stdlib

**The foundation is excellent. Time to build the unique features that make Ripple special.**