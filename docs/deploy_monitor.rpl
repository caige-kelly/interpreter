// -------------------------------------------------------------
// Ripple system automation demo (v1 canonical)
// Pure and monadic separation, try-based error handling, no ifs.
// -------------------------------------------------------------

// Read and validate deployment configuration ------------------

// Script automatically prints execution to screen. verbose = output all expressions, terse = only errors, silent = no output
// Example:
//    15 :: config :: #Args.validateMap :: ok :: 4 keys validated <-- without format 
//    {"line": 15, "assigment": "config", "lastRunFunction": "#Args.validateMap", "status": "ok", "msg": "4 keys validated"} <-- with json format

#Program.verbosity verbose
#Program.format json

config = 
  @Args.option
  |> try @File.read
  |> try #Parse.json
  |> try #Args.validateMap {
      env: string,
      url: string,
      service: string,
      restart: bool
    }

env      = config.env
url      = config.url
service  = config.service
restart  = config.restart  // boolean flag

// -------------------------------------------------------------
// Utility functions
// -------------------------------------------------------------

formatTime = _ -> #Time.now |> #Time.format "%Y-%m-%d %H:%M:%S"

// Pure because all monads are unwrapped with try
log = msg ->
  #String.concat raw [formatTime, "  ", msg, "\n"]
  |> try @File.append "./deploy.log" _ 

// Monadic assigment â€” performs visible I/O and does not handle variance -- would halt program on error
// Result object is return instead of being unwrapped
@notify = msg ->
  @IO.stdout #String.concat pretty ["[NOTIFY]", msg]

// Pure assignment - Result object is explicitly handled
deploy = target -> match @Process.start target -> 
  .ok(v)  -> log ("Deployment succeeded for " + v),
  .err(e) -> @notify ("Deployment failed for " + e) |> log "Deployment error recorded" // <- example of unused pipe values, simple chained functions

// -------------------------------------------------------------
// Status reporting
// -------------------------------------------------------------

buildPayload = status ->
  #String.concat raw [
    "{ \"env\": \"", env, "\", ",
    "\"service\": \"", service, "\", ",
    "\"status\": \"", status, "\" }"
  ]

// Pure because the monad is try-wrapped 
reportStatus = status ->
  buildPayload status
  |> try @Net.post url _

// -------------------------------------------------------------
// Main program logic
// -------------------------------------------------------------

//result is rewrapped making status monadic again
@status =
  @Net.get #String.concat raw [url + "/health"]
  |> match _ ->
      .ok  -> #Result.set value "healthy"
      .err -> #Result.set value "unreachable"

// data-driven branching using match
match status ->
  "healthy" ->
    log "Service healthy"
    |> reportStatus "healthy"
  "unreachable" ->
    @notify "Service unreachable"
    |> log "Attempting restart..."
    |> match _ ->
        .ok ->
          match restart ->
            true  -> try @Process.restart service
                     |> reportStatus "restarted"
                     |> log "Restarted successfully",
            false -> log "Restart disabled",
        .err -> @notify "Could not log status"

// -------------------------------------------------------------
// Optional: Action map version of the same restart logic
// -------------------------------------------------------------

restart_actions = {
  true:  _ -> try @Process.restart service
              |> reportStatus "restarted"
              |> log "Restarted successfully",
  false: _ -> log "Restart disabled"
}

// execute selected restart handler
restart_actions[restart] 
