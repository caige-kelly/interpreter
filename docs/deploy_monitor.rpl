// -------------------------------------------------------------
// Ripple system automation demo (v1 canonical)
// Pure and monadic separation, try-based error handling, no ifs.
// 
// ./program.rpl --config "./path/to/file.json"
// -------------------------------------------------------------

// Read and validate deployment configuration ------------------

// Script automatically prints execution to screen. verbose = output all expressions, terse = only errors, silent = no output
// Example:
//    15 :: config :: #Args.validateMap :: ok :: 4 keys validated <-- without format 
//    {"line": 15, "assigment": "config", "lastRunFunction": "#Args.validateMap", "status": "ok", "msg": "4 keys validated"} <-- with json format

#Program.verbosity verbose
#Program.output json
#Program.Retry{enable: true, count: 5, sleep: 5s, type: full} // full start from beginning, incremental start back at failing expression
#Program.timeout 5m

config = 
  @Args.option config
  |> try @File.read
  |> try #Parse.json
  |> try #Program.Args.validateMap {
      env: string,
      url: string,
      service: string,
      restart: bool
    }

env      = config.env      // string: dev
url      = config.url      // string: https://localhost:9000
service  = config.service  // string: nginx
restart  = config.restart  // bool: true 

// -------------------------------------------------------------
// Utility functions
// -------------------------------------------------------------

formatTime = _ -> #Time.now |> #Time.format "%Y-%m-%d %H:%M:%S"

log = msg ->
  #String.concat raw [formatTime, "  ", msg, "\n"]
  |> try @File.append "./deploy.log" _ 

@notify = msg ->
  @IO.stdout "[NOTIFY]" + msg

deploy = target -> match @Process.start target -> 
  .ok(v)  -> log ("Deployment succeeded for " + v),
  .err(e.system) -> @notify "Deployment failed for " + e.system |> log _

// -------------------------------------------------------------
// Status reporting
// -------------------------------------------------------------

buildPayload = status -> // could be {env: "env",...} |> #Map.stringify 
  #String.concat raw [
    "{ \"env\": \"", env, "\", ",
    "\"service\": \"", service, "\", ",
    "\"status\": \"", status, "\" }"
  ]

// Pure because the monad is try-wrapped 
reportStatus = status ->
  buildPayload _
  |> try @Net.post url _

// -------------------------------------------------------------
// Main program logic
// -------------------------------------------------------------

@status =
  match @Net.get url + "/health" ->
    .ok  -> #Result.set value "healthy"
    .err -> #Result.set value "unreachable"

match @status ->
  "healthy" -> log "Service" + _ |> reportStatus _
  "unreachable" ->
    @notify "Service" + _
    |> log "Attempting restart..."
    |> match @Process.restart service ->
        .ok(v) -> reportStatus "restarted" |> log v
        .err(e)-> @notify "Could not restat service" |> log e

// -------------------------------------------------------------
// Optional: Action map version of the same restart logic
// -------------------------------------------------------------

restart_actions = {
  true:  _ -> try @Process.restart service
              |> reportStatus "restarted"
              |> log "Restarted successfully",
  false: _ -> log "Restart disabled"
}

// execute selected restart handler
restart_actions[restart] 
