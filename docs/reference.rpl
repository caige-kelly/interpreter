# Ripple Standard Reference (v5.1 – draft)

> **Scope:** This is the *operational* language reference aligned with the current README semantics.  
> **Key shifts vs v5.0:**  
> - Everything fallible returns `Result<V,E,S>` **by default**.  
> - **Call‑site intent prefixes** control handling: `!` (critical: unwrap or crash), `?` (optional: collapse to `value | none`).  
> - `@/#` **definition markers are deprecated** (keep them as annotations in docs if desired, but semantics now hinge on call‑site intent).  
> - `tap`, `or`, `then`, `match`, and the pipeline `|>` remain core.  
> - No `^` unwrap operator; use `!` instead.  
> - `peek` and ad‑hoc `try` keywords are removed. Use `tap` and `match`/prefixes.

---

## 0. Core Model

### Result type (dual‑channel)
```ripple
Result<V, E, S> = ok(V, S) | err(E, S)

// user channel: V or E  (your semantic payload)
// sys  channel: S       (runtime metadata: duration, retries, ids, etc.)
```

**Shorthands**
```ripple
ok(v)     ≡ ok(v, none)
ok(_, s)  ≡ ok(none, s)
err(v)    ≡ err(v, none)
err(_, s) ≡ err(none, s)
```

### Call‑site intent prefixes
- **`!op ...`** → Critical: unwrap `ok` or terminate (crash for now; policy later).  
- **`?op ...`** → Optional: convert `Result<V,E,S>` to `V | none` (drop `E`, keep none).  
- **No prefix** → Return `Result<V,E,S>`; caller must handle via `match`, pipe, etc.

Examples:
```ripple
// Explicit handling (no prefix)
body := Net.get url |> match ->
  ok(b, _)  -> b
  err(e, _) -> panic("fetch failed: " + e)

// Optional
cfg := ?File.read "config.json" or default_config

// Critical
strict := !File.read "critical.json"
```

### Core operators
- `|>`   — pipeline forward (left value flows into right)  
- `or`   — associative fallback for `none` (identity: `none`)  
- `then` — sequence only if left is **not** `none` (pure tolerant chains)  
- `tap`  — observe side effects; **never** change the flowing value/result  
- `match`— pattern/guard based branching on `Result` or values  
- `_`    — placeholder for the piped value within an argument position

### Algebra
- Pure tolerant chains form a monoid: **identity = `none`**, **operator = `or`**.  
- Result propagation through pipelines (conceptual law):
  ```ripple
  ok(u, s)  |> f = f(u, s)
  err(u, s) |> f = err(u, s)
  ```
- `tap f` laws:
  ```ripple
  tap f (ok(u, s))  = ok(u, s)
  tap f (err(u, s)) = (f(u, s) then err(u, s))
  ```

---

## 1. Program Supervision & Tracing

```ripple
#Program.verbosity = quiet | normal | verbose
```

When `verbose`, the supervisor emits a trace event **for every evaluated expression** (observational only):

```
line :: binding :: function/operator :: user_value :: system_value
```

- `line`        — source line number  
- `binding`     — target name (or `_` if none)  
- `function/op` — last intrinsic/operator evaluated  
- `user_value`  — user channel (value or error)  
- `system_value`— sys channel (metadata: duration, retries, status, etc.)

**Example lines (illustrative):**
```
15 :: config  :: Map.validate :: "validated 4 keys" :: {duration: 2ms}
28 :: _       :: Net.get      :: err("ECONNREFUSED") :: {retries: 3, ms: 1200}
29 :: _       :: tap          :: ok(none)            :: {side_effect: "slack_posted"}
30 :: deploy  :: or           :: {status: "skipped"} :: {source: "fallback"}
```

---

## 2. Type System & Values

- **Static inference**, no implicit coercions.  
- **Fundamental:** `number` (unified int/float, keeps int precision when possible), `bool`, `string`, `none`.  
- **Composite:** `[T]` (list), `{key: T}` (map), and `Result<V,E,S>` (fallible).

```ripple
x := 42
y := 3.14
name := "alice"
active := true
nothing := none
```

Numbers compose naturally:
```ripple
sum := 10 + 5
prod := 2.5 * 4
mixed := 10 + 3.14
```

---

## 3. Variables & Immutability

- Bindings are **immutable**.  
- `:=` creates a new binding; **rebind** to “shadow” the old value.

```ripple
count := 1
count := count + 1   // 2
count := count * 2   // 4
```

Optional explicit annotation (rare, for clarity):
```ripple
resp: Result<User, Error, Meta> = Net.get url
```

---

## 4. Functions

Everything is a lambda bound to a name (no `fn` keyword). Calls do **not** use parentheses.

```ripple
add := a, b -> a + b
result := add 10 32     // 42

multiply := x: number, y: number ->
  x * y

process := x ->
  y := x + 1
  z := y * 2
  z                     // implicit return (last expression)
```

**Stdlib convention:** All fallible operations return `Result<V,E,S>`.  
Purity is expressed by **call‑site intent** (`!`, `?`, or explicit `match`).

---

## 5. Result Interpretation (Caller‑Driven)

```ripple
// Monadic: explicit handling
data := Net.get "https://example.com/api" |> match ->
  ok(body, _)  -> body
  err(msg, _)  -> panic("failed: " + msg)

// Optional: collapse to value | none
maybe_body := ?Net.get "https://example.com/api"

// Critical: unwrap or crash
body := !Net.get "https://example.com/api"
```

---

## 6. Pipelines (`|>`)

Forward the left value into the right expression. Use `_` to position the piped value among other args.

```ripple
result :=
  "hello world"
    |> String.uppercase _
    |> String.split " "
```

Another example (cleaned and consistent):
```ripple
Default := { h: "", b: "", status_code: -1, metadata: "additional" }
url := "example.com/data"

data :=
  Net.get ("https://" + url)
    |> match ->
         ok(resp, _) -> resp
         err(_, _)   -> Net.get ("http://" + url) |> match ->
                           ok(resp2, _) -> resp2
                           err(_, _)    -> none
    |> ?Map.parse json _
    then Map.translate Default _ { header: h, body: b }
    or Default
```

---

## 7. Tolerant Operators

### `or` — fallback for `none` (identity = `none`)
```ripple
cfg := (?File.read "./optional.json") or Map.new { default: true }
```

### `then` — sequence when value is **not** `none`
```ripple
result :=
  ?File.read "./required.json"
    then Map.parse _
    then Map.validate schema _
```

---

## 8. `tap` — Observational Side Effects

`tap` inspects the flowing value/result, triggers side effects, and **returns the original**.

Errors:
```ripple
post_result :=
  Net.post url payload
    |> tap err(msg, meta) ->
         Slack.post ("Error: " + msg)
    |> match ->
         ok(v, _)  -> v
         err(_, _) -> Map.new { status: "failed" }
```

Success:
```ripple
parsed :=
  Net.get url
    |> tap ok(body, meta) -> IO.stdout ("Fetched in " + meta.duration + "ms")
    |> match ->
         ok(body, _) -> Map.parse body
         err(_,   _) -> err("fetch failed")
```

---

## 9. Pattern Matching (`match`)

Replace `if/else` entirely. Patterns + optional guards control flow.

### Match on `Result`
```ripple
status_msg :=
  Net.get "https://example.com/status"
    |> match ->
         ok(body, meta) -> "Service healthy: " + body.status
         err(msg,  meta) -> "Service down: " + msg
```

### Match on values
```ripple
message :=
  "active" |> match ->
    "active" -> "Running"
    "paused" -> "Paused"
    any      -> "Unknown"
```

**Exhaustiveness**
- Algebraic/finite domains (e.g., `Result`, `bool`) must cover all constructors.  
- Open domains (`number`, `string`) require `any` as a catch‑all.

---

## 10. Collections

### Lists
```ripple
numbers := [1, 2, 3, 4, 5]
empty_list := []
nested := [[1, 2], [3, 4], [5, 6]]
```

### Maps
```ripple
user := { id: 42, name: "alice", email: "alice@example.com" }
empty_map := {}

user_name := Map.get user "name"  // "alice" | none
user_name or "unknown"
```

> **Convention:** `Map.get` returns `value | none`. Most other Map ops are fallible and return `Result`.

---

## 11. None Propagation (Pure/Tolerant Chains)

When operating on `value | none`, `none` short‑circuits tolerant chains; later steps are skipped.

```ripple
result :=
  ?File.read "./missing.json"
    then Map.parse _
    then IO.stdout _   // never reached
// result == none
```

---

## 12. Standard Library (Signatures)

> **Rule of thumb:** All fallible I/O and transformations return `Result<V,E,S>`.  
> Pure/total transforms return plain values. `Map.get` is special‑cased to `value | none`.

### File
```ripple
File.read  : path -> Result<string, Error, Meta>
File.write : path data -> Result<none, Error, Meta>
```

### Map
```ripple
Map.parse    : text -> Result<Map, Error, Meta>
Map.validate : map schema -> Result<Map, Error, Meta>
Map.translate: defaults map -> Result<Map, Error, Meta>
Map.get      : map key -> value | none
Map.new      : initial -> Map
```

### Net
```ripple
Net.get  : url -> Result<string, Error, Meta>
Net.post : url body -> Result<string, Error, Meta>
```

### String (pure)
```ripple
String.uppercase : text -> string
String.split     : text sep -> [string]
```

### IO (fallible side effects)
```ripple
IO.stdout : message -> Result<none, Error, Meta>
IO.exit   : code -> Result<none, Error, Meta>
```

### Slack (fallible side effects)
```ripple
Slack.post : message -> Result<none, Error, Meta>
```

---

## 13. Comprehensive Example

```ripple
targets := [
  {arch: "x86_64", os: "linux"},
  {arch: "aarch64", os: "linux"},
  {arch: "x86_64", os: "darwin"},
]

build := t ->
  !Process.run ("cargo build --release --target " + t.arch + "-" + t.os)
    |> sign
    |> upload_to "releases/"

results := targets |> List.parallel_map build max_concurrent: 4

results |> List.partition |> match p ->
  p p.failure.length == 0 ->
    IO.stdout ("✓ All " + p.success.length + " builds succeeded")

  p p.success.length == 0 ->
    !Alert.pagerduty ("✗ Build completely failed")
    !IO.exit 1

  p ->
    IO.stderr ("⚠ Partial: " + p.success.length + " ok, " + p.failure.length + " failed")
    Alert.slack ("Build partially failed. Succeeded: " + p.success)
```

---

## 14. Status Notes (v5.1 – draft)

- Prefix semantics (`!`, `?`) are **authoritative** at call sites.  
- `@/#` **definition markers are deprecated**; tools may still display them as hints.  
- `match`, `tap`, pipelines, `or`, `then`, placeholder `_` are core.  
- Parentheses are **only** for expression grouping (not function calls).  
- No boolean keywords; boolean operators `&&`, `||`, `!` are available for guards when needed.

---

*End of Reference*
